<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>JNIpp: EmailValidator.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">JNIpp&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">JNI meets C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00002.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">EmailValidator.cpp</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;EmailValidator.h&quot;</span>

<span class="comment">/**************************************/</span>

<span class="comment">/* Email validator function which uses Pattern and Matcher</span>
<span class="comment"> *  classes implemented below.</span>
<span class="comment"> */</span>


<span class="comment">/* We compile email pattern only once.</span>
<span class="comment"> * Note that we use pointer to Pattern instead of advised PPattern.</span>
<span class="comment"> *</span>
<span class="comment"> * The problem with using PPattern is that destructor of g_emailPattern</span>
<span class="comment"> *  will be called on library unload *after* the JNI unload event</span>
<span class="comment"> *  JNI_OnUnload. So jni::GetEnv() which every jni:: function use will </span>
<span class="comment"> *  fail and call jni::FatalError() to report a failure. jni::FatalError()</span>
<span class="comment"> *  will try to call jni::GetEnv()-&gt;FatalError() but since JNIEnv is not</span>
<span class="comment"> *  available jni::FatalError() will abort the whole process with abort().</span>
<span class="comment"> *</span>
<span class="comment"> * So we use (and leak) Pattern pointer.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> Pattern* g_emailPattern=0;


<span class="keywordtype">bool</span> ValidateEmail(<span class="keyword">const</span> <span class="keywordtype">char</span>* email) {
    <span class="keywordflow">if</span> (!email || !*email) {
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (!g_emailPattern) {
        <span class="comment">// NOT THREAD SAFE!</span>
        <span class="comment">// Add locking to your taste.</span>
        PPattern pattern=Pattern::Compile(
             <span class="stringliteral">&quot;^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@&quot;</span>
            <span class="stringliteral">&quot;[A-Za-z0-9]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$&quot;</span>
        );
        g_emailPattern=pattern.Detach();
    }
    
    <span class="comment">// Compare with Java&#39;s &quot;pattern.matcher(email).matches()&quot;.</span>
    <span class="keywordflow">return</span> g_emailPattern-&gt;CreateMatcher(email)-&gt;Matches();
}


<span class="comment">/**************************************/</span>

<span class="comment">/* Let JB_ macros know the name of the class we are implementing.</span>
<span class="comment"> *</span>
<span class="comment"> * Each wrapper class implementation must start with a definition</span>
<span class="comment"> *  of the current class.</span>
<span class="comment"> *</span>
<span class="comment"> * Remember that JB_ macros are only usable when JB_CURRENT_CLASS </span>
<span class="comment"> *  is defined. Otherwise you will get compiler errors.</span>
<span class="comment"> */</span>
<span class="preprocessor">#define JB_CURRENT_CLASS Pattern</span>
<span class="preprocessor"></span>

<span class="comment">/* Define information about Java class we are going to call.</span>
<span class="comment"> *</span>
<span class="comment"> * Note that there are no commas between method definitions.</span>
<span class="comment"> * Also note that static methods are denoted with &#39;+&#39;.</span>
<span class="comment"> *</span>
<span class="comment"> * Fields are declared the same way - see JB_DEFINE_WRAPPER_CLASS()</span>
<span class="comment"> *  documentation.</span>
<span class="comment"> */</span>
<a name="a0"></a><a class="code" href="a00026.html#ad0c4f80cfc9760c92307575e6342a1e7" title="Defines Java bindings for the current wrapper class.">JB_DEFINE_WRAPPER_CLASS</a>(
    <span class="stringliteral">&quot;java/util/regex/Pattern&quot;</span>
    ,
    NoFields
    ,
    Methods
    (
        CompileTag,
        <span class="stringliteral">&quot;+compile&quot;</span>,
        <span class="stringliteral">&quot;(Ljava/lang/String;)Ljava/util/regex/Pattern;&quot;</span>
    )
    (
        CreateMatcherTag,
        <span class="stringliteral">&quot;matcher&quot;</span>,
        <span class="stringliteral">&quot;(Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;&quot;</span>
    )
)

<span class="comment">/* Wrapping constructor.</span>
<span class="comment"> * This constructor is used in implementation of PPattern::Wrap().</span>
<span class="comment"> */</span>
Pattern::Pattern(const jni::LObject&amp; pattern):
    java::Object(pattern)
{
}

PPattern Pattern::Compile(<span class="keyword">const</span> <span class="keywordtype">char</span>* regex) {
    <span class="keywordflow">return</span> Compile(<a name="a1"></a><a class="code" href="a00017.html#a928c0b2ab56179af5b424417a7e2d1fd" title="Instantiates ObjectType and wraps it into ObjectPointer.">java::PString::New</a>(regex));
}

<span class="comment">/* </span>
<span class="comment"> * Here is what happens in this method:</span>
<span class="comment"> * - JB_CALL_STATIC() calls JB_INIT_CLASS() to make sure class descriptor</span>
<span class="comment"> *    (defined by JB_DEFINE_CLASS) is initialized.</span>
<span class="comment"> * - JB_INIT_CLASS() gets Java class &quot;java/util/regex/Pattern&quot; and retrieves</span>
<span class="comment"> *    method/field ids for each method or field defined by JB_DEFINE_WRAPPER_CLASS().</span>
<span class="comment"> *    Initialization happens only once (via pthread_once).</span>
<span class="comment"> * - jni::CallStaticObjectMethod() is called with method id for the &#39;CompileTag&#39;</span>
<span class="comment"> *    method. You can get method id for the tag with JB_METHOD_ID() macro.</span>
<span class="comment"> * - Result of method call is wrapped into the Pattern class. Note that for</span>
<span class="comment"> *    performance reasons PPattern::Wrap() doesn&#39;t check that you are wrapping</span>
<span class="comment"> *    object of correct class (java.util.regex.Pattern or derived).</span>
<span class="comment"> */</span>
PPattern Pattern::Compile(<a name="_a2"></a><a class="code" href="a00017.html" title="Smart pointer for classes derived from Object.">java::PString</a> regex) {
    <span class="keywordflow">return</span> PPattern::Wrap(<a name="a3"></a><a class="code" href="a00026.html#a4edd71ef59c52e42356f00bf1bdd8a17" title="Calls static method identified by MethodTag.">JB_CALL_STATIC</a>(ObjectMethod,CompileTag,regex));
}

PMatcher Pattern::CreateMatcher(<span class="keyword">const</span> <span class="keywordtype">char</span>* input)<span class="keyword"> const </span>{
    <span class="keywordflow">return</span> CreateMatcher(<a class="code" href="a00017.html#a928c0b2ab56179af5b424417a7e2d1fd" title="Instantiates ObjectType and wraps it into ObjectPointer.">java::PString::New</a>(input));
}

<span class="comment">/* When calling non-static methods (or accessing fields) use</span>
<span class="comment"> * _THIS version of JB_ macros.</span>
<span class="comment"> */</span>
PMatcher Pattern::CreateMatcher(<a class="code" href="a00017.html" title="Smart pointer for classes derived from Object.">java::PCharSequence</a> input)<span class="keyword"> const </span>{
    <span class="keywordflow">return</span> PMatcher::Wrap(<a name="a4"></a><a class="code" href="a00026.html#a3715efe639bf5a13c8e4e8603e2fc1c3" title="Calls method identified by MethodTag on the current object; use in member functions.">JB_CALL_THIS</a>(ObjectMethod,CreateMatcherTag,input));
}

<span class="comment">/* Finished with implementation of Pattern class, undefine</span>
<span class="comment"> *  JB_CURRENT_CLASS. JB_ macros will not work past this line.</span>
<span class="comment"> */</span>
<span class="preprocessor">#undef JB_CURRENT_CLASS</span>
<span class="preprocessor"></span>

<span class="comment">/**************************************/</span>

<span class="comment">/* Matcher class implementation. */</span>

<span class="preprocessor">#define JB_CURRENT_CLASS Matcher</span>
<span class="preprocessor"></span>
<a class="code" href="a00026.html#ad0c4f80cfc9760c92307575e6342a1e7" title="Defines Java bindings for the current wrapper class.">JB_DEFINE_WRAPPER_CLASS</a>(
    <span class="stringliteral">&quot;java/util/regex/Matcher&quot;</span>
    ,
    NoFields
    ,
    Methods
    (
        Matches,
        <span class="stringliteral">&quot;matches&quot;</span>,
        <span class="stringliteral">&quot;()Z&quot;</span>
    )
)

Matcher::Matcher(const jni::LObject&amp; matcher):
    java::Object(matcher)
{
}

<span class="comment">/* Note that we call &#39;BoolMethod&#39;, which expands to jni::CallBoolMethod().</span>
<span class="comment"> * This is a version of traditional jni::CallBooleanMethod() which converts</span>
<span class="comment"> *  jboolean to bool.</span>
<span class="comment"> */</span>
<span class="keywordtype">bool</span> Matcher::Matches()<span class="keyword"> const </span>{
    <span class="keywordflow">return</span> <a class="code" href="a00026.html#a3715efe639bf5a13c8e4e8603e2fc1c3" title="Calls method identified by MethodTag on the current object; use in member functions.">JB_CALL_THIS</a>(BoolMethod,Matches);
}

<span class="preprocessor">#undef JB_CURRENT_CLASS</span>
<span class="preprocessor"></span>

<span class="comment">/**************************************/</span>

<span class="preprocessor">#ifdef ONLY_FOR_DOXYGEN</span>
<span class="preprocessor"></span><span class="comment">// Wire this example to:</span>
<a name="_a5"></a><a class="code" href="a00015.html" title="The Object class, root of all.">java::Object</a>;
<span class="preprocessor">#endif</span>
</pre></div> </div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Thu Jun 9 2011 01:07:48 for JNIpp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
